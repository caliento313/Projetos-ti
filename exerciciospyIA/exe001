#1. Árvore Binária de Busca
#• 	Adicione métodos para travessias em ordem, pré-ordem e pós-ordem.
#• 	Crie uma função que verifique se a árvore é balanceada.
class No:
    def __init__(self, valor):
        self.valor = valor
        self.esquerda = None
        self.direita = None


class ArvoreBinariaBusca:
    def __init__(self):
        self.raiz = None

    def inserir(self, valor):
        self.raiz = self._inserir_recursivo(self.raiz, valor)

    def _inserir_recursivo(self, no, valor):
        if no is None:
            return No(valor)
        if valor < no.valor:
            no.esquerda = self._inserir_recursivo(no.esquerda, valor)
        else:
            no.direita = self._inserir_recursivo(no.direita, valor)
        return no

    def buscar(self, valor):
        return self._buscar_recursivo(self.raiz, valor)

    def _buscar_recursivo(self, no, valor):
        if no is None or no.valor == valor:
            return no
        if valor < no.valor:
            return self._buscar_recursivo(no.esquerda, valor)
        else:
            return self._buscar_recursivo(no.direita, valor)

    def remover(self, valor):
        self.raiz = self._remover_recursivo(self.raiz, valor)

    def _remover_recursivo(self, no, valor):
        if no is None:
            return None
        if valor < no.valor:
            no.esquerda = self._remover_recursivo(no.esquerda, valor)
        elif valor > no.valor:
            no.direita = self._remover_recursivo(no.direita, valor)
        else:
            # Nó com apenas um filho ou nenhum
            if no.esquerda is None:
                return no.direita
            elif no.direita is None:
                return no.esquerda
            # Nó com dois filhos: obter o sucessor
            sucessor = self._minimo(no.direita)
            no.valor = sucessor.valor
            no.direita = self._remover_recursivo(no.direita, sucessor.valor)
        return no

    def _minimo(self, no):
        atual = no
        while atual.esquerda is not None:
            atual = atual.esquerda
        return atual

    def em_ordem(self):
        return self._em_ordem(self.raiz)

    def _em_ordem(self, no):
        if no is None:
            return []
        return self._em_ordem(no.esquerda) + [no.valor] + self._em_ordem(no.direita)

    def pre_ordem(self):
        return self._pre_ordem(self.raiz)

    def _pre_ordem(self, no):
        if no is None:
            return []
        return [no.valor] + self._pre_ordem(no.esquerda) + self._pre_ordem(no.direita)

    def pos_ordem(self):
        return self._pos_ordem(self.raiz)

    def _pos_ordem(self, no):
        if no is None:
            return []
        return self._pos_ordem(no.esquerda) + self._pos_ordem(no.direita) + [no.valor]

    def esta_balanceada(self):
        return self._verificar_balanceamento(self.raiz) != -1

    def _verificar_balanceamento(self, no):
        if no is None:
            return 0
        altura_esq = self._verificar_balanceamento(no.esquerda)
        altura_dir = self._verificar_balanceamento(no.direita)
        if altura_esq == -1 or altura_dir == -1 or abs(altura_esq - altura_dir) > 1:
            return -1
        return max(altura_esq, altura_dir) + 1
if __name__ == "__main__":
    arvore = ArvoreBinariaBusca()
    for valor in [10, 5, 15, 3, 7, 12, 18]:
        arvore.inserir(valor)

    print("Em ordem:", arvore.em_ordem())
    print("Pré-ordem:", arvore.pre_ordem())
    print("Pós-ordem:", arvore.pos_ordem())
    print("Está balanceada?", arvore.esta_balanceada())

    arvore.remover(10)
    print("Após remover 10:", arvore.em_ordem())
